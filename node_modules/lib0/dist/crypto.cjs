'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var encoding = require('./buffer-22bb9fae.cjs');
var string = require('./string-ad04f734.cjs');
var webcrypto = require('lib0/webcrypto');
require('./environment-f6386808.cjs');
require('./map-28a001c9.cjs');
require('./conditions-fb475c70.cjs');
require('./storage.cjs');
require('./function-40d38a5b.cjs');
require('./array-42d0736b.cjs');
require('./set-b596ef38.cjs');
require('./object-fe9c0021.cjs');
require('./binary-ac8e39e2.cjs');
require('./math-08e068f9.cjs');
require('./number-e62129bc.cjs');
require('./error-873c9cbf.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var webcrypto__namespace = /*#__PURE__*/_interopNamespace(webcrypto);

/* eslint-env browser */

/* istanbul ignore next */
/**
 * @param {string | Uint8Array} data
 * @return {Uint8Array}
 */
const toBinary = data => typeof data === 'string' ? string.encodeUtf8(data) : data;

/**
 * @experimental The API is not final!
 *
 * Derive an symmetric key using the Password-Based-Key-Derivation-Function-2.
 *
 * @param {string | Uint8Array} secret
 * @param {string | Uint8Array} salt
 * @param {Object} opts
 * @param {boolean} [opts.extractable]
 * @param {Array<'sign'|'verify'|'encrypt'|'decrypt'>} [opts.usages]
 * @return {PromiseLike<CryptoKey>}
 */
const deriveSymmetricKey = (secret, salt, { extractable = false, usages = ['encrypt', 'decrypt'] } = {}) => {
  const binSecret = toBinary(secret);
  const binSalt = toBinary(salt);
  return webcrypto__namespace.subtle.importKey(
    'raw',
    binSecret,
    'PBKDF2',
    false,
    ['deriveKey']
  ).then(keyMaterial =>
    webcrypto__namespace.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: binSalt, // NIST recommends at least 64 bits
        iterations: 600000, // OWASP recommends 600k iterations
        hash: 'SHA-256'
      },
      keyMaterial,
      {
        name: 'AES-GCM',
        length: 256
      },
      extractable,
      usages
    )
  )
};

/* istanbul ignore next */
/**
 * @param {Object} opts
 * @param {boolean} [opts.extractable]
 * @param {Array<'sign'|'verify'|'encrypt'|'decrypt'>} [opts.usages]
 */
const generateAsymmetricKey = ({ extractable = false, usages = ['sign', 'verify'] } = {}) =>
  webcrypto__namespace.subtle.generateKey(
    {
      name: 'ECDSA',
      namedCurve: 'P-384'
    },
    extractable,
    usages
  );

/* istanbul ignore next */
/**
 * @param {CryptoKey} key - Symmetric or Asymmetric key
 */
const exportKey = key => webcrypto__namespace.subtle.exportKey('jwk', key);

/* istanbul ignore next */
/**
 * @param {any} jwk
 * @param {Object} opts
 * @param {boolean} [opts.extractable]
 * @param {Array<'sign'|'verify'|'encrypt'|'decrypt'>} [opts.usages]
 */
const importSymmetricKey = (jwk, { extractable = false, usages = ['encrypt', 'decrypt'] } = {}) =>
  webcrypto__namespace.subtle.importKey('jwk', jwk, 'PBKDF2', extractable, usages);

/* istanbul ignore next */
/**
 * @param {any} jwk
 * @param {Object} opts
 * @param {boolean} [opts.extractable]
 * @param {Array<'sign'|'verify'|'encrypt'|'decrypt'>} [opts.usages]
 */
const importAsymmetricKey = (jwk, { extractable = false, usages = ['encrypt', 'decrypt'] } = {}) =>
  webcrypto__namespace.subtle.importKey('jwk', jwk, { name: 'ECDSA', namedCurve: 'P-384' }, extractable, usages);

/**
 * @experimental The API is not final!
 *
 * Encrypt some data using AES-GCM method.
 *
 * @param {Uint8Array} data data to be encrypted
 * @param {CryptoKey} key
 * @return {PromiseLike<Uint8Array>} encrypted, base64 encoded message
 */
const encrypt = (data, key) => {
  const iv = webcrypto__namespace.getRandomValues(new Uint8Array(16)); // 92bit is enough. 128bit is recommended if space is not an issue.
  return webcrypto__namespace.subtle.encrypt(
    {
      name: 'AES-GCM',
      iv
    },
    key,
    data
  ).then(cipher => {
    const encryptedDataEncoder = encoding.createEncoder();
    // iv may be sent in the clear to the other peers
    encoding.writeUint8Array(encryptedDataEncoder, iv);
    encoding.writeVarUint8Array(encryptedDataEncoder, new Uint8Array(cipher));
    return encoding.toUint8Array(encryptedDataEncoder)
  })
};

/**
 * @experimental The API is not final!
 *
 * Decrypt some data using AES-GCM method.
 *
 * @param {Uint8Array} data
 * @param {CryptoKey} key
 * @return {PromiseLike<Uint8Array>} decrypted buffer
 */
const decrypt = (data, key) => {
  const dataDecoder = encoding.createDecoder(data);
  const iv = encoding.readUint8Array(dataDecoder, 16);
  const cipher = encoding.readVarUint8Array(dataDecoder);
  return webcrypto__namespace.subtle.decrypt(
    {
      name: 'AES-GCM',
      iv
    },
    key,
    cipher
  ).then(data => new Uint8Array(data))
};

/**
 * @experimental The API is not final!
 *
 * Sign a message
 *
 * @param {Uint8Array} data
 * @param {CryptoKey} privateKey
 * @return {PromiseLike<Uint8Array>} signature
 */
const sign = (data, privateKey) =>
  webcrypto__namespace.subtle.sign(
    {
      name: 'ECDSA',
      hash: { name: 'SHA-384' }
    },
    privateKey,
    data
  ).then(signature => new Uint8Array(signature));

/**
 * @experimental The API is not final!
 *
 * Sign a message
 *
 * @param {Uint8Array} signature
 * @param {Uint8Array} data
 * @param {CryptoKey} publicKey
 * @return {PromiseLike<boolean>} signature
 */
const verify = (signature, data, publicKey) =>
  webcrypto__namespace.subtle.verify(
    {
      name: 'ECDSA',
      hash: { name: 'SHA-384' }
    },
    publicKey,
    signature,
    data
  );

exports.decrypt = decrypt;
exports.deriveSymmetricKey = deriveSymmetricKey;
exports.encrypt = encrypt;
exports.exportKey = exportKey;
exports.generateAsymmetricKey = generateAsymmetricKey;
exports.importAsymmetricKey = importAsymmetricKey;
exports.importSymmetricKey = importSymmetricKey;
exports.sign = sign;
exports.verify = verify;
//# sourceMappingURL=crypto.cjs.map
